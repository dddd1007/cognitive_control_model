---
title: "Behavioral_data_analysis"
author: "Xiaokai Xia"
format: html
editor: visual
---

# 对行为数据的分析

对行为数据进行分析，关注被试是否呈现出 Simon effect 与 PC 效应。对数据进行三因素方差分析，查看结果。

```{r}
library(tidyverse)
library(apa)
library(here)
library(ggplot2)
library(rstatix)
library(ggpubr)
library(patchwork)
```

## 0. 读取数据

```{r}
raw_data <- read_csv("/Users/dddd1007/project2git/cognitive_control_model/data/input/all_data_with_RL_BL_estimate_result.csv")
```

**按条件去掉 RT 的 outlier 和错误试次**

```{r}
data_without_error <- filter(raw_data, Type == "hit")
data_without_outlier <- data_without_error %>%
                        group_by(Subject, congruency, prop, condition) %>%
                        filter(abs(RT - mean(RT)) < (sd(RT) * 3))
```

## 1. 按条件计算方差分析并绘图

### RT

#### Anova

```{r}
data_foranalysis <- data_without_outlier %>%
    group_by(Subject_num, congruency, prop, condition) %>%
    summarise(mean_rt = mean(RT)) %>%
    as_tibble()

data_foranalysis %>%
    anova_test(dv = mean_rt, wid = Subject_num,
               within = c(congruency, prop, condition)) %>%
    get_anova_table()
```

#### Plot

```{r}
# anova_RT_plot <- ggboxplot(data_foranalysis, 
#           x = "congruency", y = "mean_rt", 
#           fill = "condition", ylab = "RT (ms)", 
#           font.label = list(size = 14)) %>%
#           facet(facet.by = "prop")
# anova_RT_plot
# ggsave(here("data", "output", "plot",
#             "anova_RT_plot.png"),
#         plot = anova_RT_plot,
#         dpi = 300, scale = 0.65)
# 
data_forplot <- unite(data_foranalysis, col = "factor",
                      congruency, condition, sep = "/", remove = FALSE)
data_forplot$factor <- as.factor(data_forplot$factor)
anova_RT_plot_bar <- ggbarplot(data_forplot,
                               x = "factor", y = "mean_rt",
                               fill = "condition", color = "condition",
                               add = "mean_se",
                               facet.by = "prop",
                               ylab = "RT (ms)", ylim = c(420, 550),
                               add.params = list(color = "black"),
                               font.label = list(size = 14))
anova_RT_plot_bar 
```

#### Simple Effect

```{r}
data_without_outlier %>%
    filter(prop == 80) %>%
    group_by(Subject_num, congruency) %>%
    summarise(mean_rt = mean(RT), .groups = "drop") %>%
    pivot_wider(names_from = "congruency",
                values_from = "mean_rt") -> foo1
get_summary_stats(foo1)
t.test(x = foo1$con, y = foo1$inc, alternative = "less", paired = TRUE) %>% t_apa()

data_without_outlier %>%
    filter(prop == 20) %>%
    group_by(Subject_num, congruency) %>%
    summarise(mean_rt = mean(RT), .groups = "drop") %>%
    pivot_wider(names_from = "congruency",
                values_from = "mean_rt") -> foo2
get_summary_stats(foo2)
t.test(x = foo2$con, y = foo2$inc, alternative = "greater", paired = TRUE) %>% t_apa()
```

### Error rate

```{r}
raw_data %>%
    mutate(correct_action = if_else(.data$Type == "hit", 1, 0)) %>%
    group_by(Subject_num, congruency, prop, condition) %>%
    summarise(mean_error_action = (1 - mean(correct_action)) * 100, .groups = "drop") %>%
    anova_test(dv = mean_error_action, wid = Subject_num,
               within = c(congruency, prop, condition))
```

Plot

```{r}
# raw_data %>%
#     mutate(correct_action = if_else(.data$Type == "hit", 1, 0)) %>%
#     group_by(congruency, prop, condition) %>%
#     summarise(mean_error_action = (1 - mean(correct_action)) * 100) %>%
#     ggbarplot(x = "congruency", y = "mean_error_action",
#           fill = "condition", color = "condition",
#           ylab = "Error percentage", position = position_dodge(),
#           font.label = list(size = 14)) %>%
#           facet(facet.by = "prop") -> anova_error_rate_plot
# anova_error_rate_plot
# # ggsave(here("data", "output", "plot",
# #             "anova_error_rate_plot.png"),
# #         plot = anova_error_rate_plot,
# #         dpi = 300, scale = 0.65)
raw_data %>%
    mutate(correct_action = if_else(.data$Type == "hit", 1, 0)) %>%
    group_by(Subject_num, congruency, prop, condition) %>%
    summarise(mean_error_action = (1 - mean(correct_action)) * 100, .groups = "drop") %>%
    unite(col = "factor", congruency, condition, sep = "/", remove = FALSE) -> error_rate_forplot
error_rate_forplot$factor <- as.factor(error_rate_forplot$factor)
error_rate_plot_bar <- ggbarplot(error_rate_forplot,
                                 x = "factor", y = "mean_error",
                                 fill = "condition", color = "condition",
                                 add = "mean_se",
                                 facet.by = "prop",
                                 ylab = "Error percentage", 
                                 add.params = list(color = "black"),
                                 font.label = list(size = 14))
error_rate_plot_bar
```

## 2. Simon Effect 及其反转

### RT

```{r}
data_add_simon_effect <- data_without_outlier %>%
    group_by(Subject_num, congruency, prop, condition) %>%
    summarise(mean_rt = mean(RT)) %>%
    pivot_wider(names_from = congruency, values_from = mean_rt) %>%
    mutate(simon_effect = inc - con)

# simon_RT_plot <- data_add_simon_effect %>%
#     as_data_frame() %>%
#     group_by(prop, condition) %>%
#     summarise(mean_simon = mean(simon_effect)) %>%
#     ggbarplot(x = "condition", y = "mean_simon", fill = "condition", color = "condition",
#               ylab = "Simon Effect (ms)", position = position_dodge(),
#               font.label = list(size = 14)) %>%
#     facet(facet.by = "prop") + geom_hline(yintercept = 0, linetype = 2, color = "darkgray", size = 1)  + rremove("legend")
# simon_RT_plot

data_add_simon_effect %>%
    as_data_frame() %>%
    select(-con, -inc) %>%
    ggbarplot(x = "condition", y = "simon_effect", fill = "condition", color = "condition",
              ylab = "Simon Effect in RT (ms)", facet.by = "prop", 
              add = "mean_se", add.params = list(color = "black"),
              font.label = list(size = 14)) + 
              geom_hline(yintercept = 0, linetype = 2, color = "darkgray", size = 1)  + 
              rremove("legend") -> simon_RT_plot
simon_RT_plot
```

### Error Rate

```{r}
raw_data %>%
    mutate(correct_action = if_else(.data$Type == "hit", 1, 0)) %>%
    group_by(Subject_num, congruency, prop, condition) %>%
    summarise(mean_error_action = (1 - mean(correct_action)) * 100) %>%
    pivot_wider(names_from = congruency, values_from = mean_error_action) %>%
    mutate(simon_effect_error = inc - con) %>%
    select(-con, -inc) %>%
    ggbarplot(x = "condition", y = "simon_effect_error", fill = "condition", color = "condition",
              ylab = "Simon Effect in EP", facet.by = "prop", 
              add = "mean_se", add.params = list(color = "black"),
              font.label = list(size = 14)) + 
              geom_hline(yintercept = 0, linetype = 2, color = "darkgray", size = 1)  + 
              rremove("legend") -> simon_error_rate_plot
simon_error_rate_plot

#     ggbarplot(x = "condition", y = "simon_effect_error", fill = "condition", color = "condition",
#               ylab = "Simon Effect (Error rate)", position = position_dodge(),
#               font.label = list(size = 14)) %>%
#     facet(facet.by = "prop") + geom_hline(yintercept = 0, linetype = 2, color = "darkgray", size = 1)  + rremove("legend") -> simon_error_rate_plot
# simon_error_rate_plot
# ggsave(here("data", "output", "plot",
#             "simon_error_rate_plot.png"),
#         plot = simon_error_rate_plot,
#         dpi = 300, scale = 0.65)
```

## 3. 拼图

```{r}
library(patchwork)
beh_result_plot <- (anova_RT_plot_bar | error_rate_plot_bar) / (simon_RT_plot | simon_error_rate_plot) + plot_annotation(tag_levels = 'A')
beh_result_plot
ggsave(here("data", "output", "plot",
            "beh_result_plot.png"),
        plot = beh_result_plot, width = 20, height = 10,
        dpi = 300, scale = 0.65)
```

## 4. 无关维度信息的学习过程

当反转的时候, simon effect 应该逐渐变化，或者是各条件的反应时也会随着比例呈现逐步变化的趋势。我们尝试使用 moving window 内的均值将其描述出来。

```{r}
sub_1_data <- filter(raw_data, Subject_num == 1)

library(data.table)
sub_1_table = data.table::as.data.table(filter(sub_1_data, congruency == "con"))
```

```{r}
windowed_mean <- frollmean(sub_1_table[, RT], 20)

plot_dataframe <- data.frame(x = 1:length(windowed_mean), y = windowed_mean)
ggplot(plot_dataframe) + geom_line(aes(x, y))
```

选出 v80 开始的被试

```{r}
selected_data <- raw_data %>%
        filter(Trial == 1, logfile_name == "v_80")
selected_sub_list <- selected_data$Subject_num

calc_con_moving_window_mean <- function (dataframe, moving_window_len) {
  prep_data <- dataframe %>%
    filter(congruency == "con")
  prep_data <- data.table::as.data.table(prep_data)
  windowed_mean <- frollmean(prep_data[, RT], moving_window_len)
  return(windowed_mean)
}

selected_sub_list <- c(1,9,13,17,25,29)
result_list <- list()
raw_data <- read.csv("/Users/dddd1007/project2git/cognitive_control_model/data/input/pure_all_sub_data.csv")
for (i in seq_len(length(selected_sub_list))) {
  result_list[[i]] <- calc_con_moving_window_mean(filter(raw_data, Subject_num == selected_sub_list[i]), 20)
}

con_RT_matrix <- do.call(rbind, result_list)
mean_RT <- apply(con_RT_matrix, 2, mean, na.rm = TRUE)
plot_data_con <- data.frame(idx = 1:length(mean_RT), mean_RT)
v80_minisimon <- ggplot(plot_data_con) + geom_line(aes(x = idx, y = mean_RT))
v80_minisimon + theme_pubr()
```

```{r}
calc_inc_moving_window_mean <- function (dataframe, moving_window_len) {
  prep_data <- dataframe %>%
    filter(congruency == "inc")
  prep_data <- data.table::as.data.table(prep_data)
  windowed_mean <- frollmean(prep_data[, RT], moving_window_len)
  return(windowed_mean)
}

selected_sub_list <- c(1,9,13,17,25,29)
result_list <- list()
raw_data <- read.csv("/Users/dddd1007/project2git/cognitive_control_model/data/input/pure_all_sub_data.csv")
for (i in seq_len(length(selected_sub_list))) {
  result_list[[i]] <- calc_inc_moving_window_mean(filter(raw_data, Subject_num == selected_sub_list[i]), 20)
}

inc_RT_matrix <- do.call(rbind, result_list)
mean_RT <- apply(inc_RT_matrix, 2, mean, na.rm = TRUE)
plot_data_inc <- data.frame(idx = 1:length(mean_RT), mean_RT)
ggplot(plot_data_inc) + geom_line(aes(x = idx, y = mean_RT))
```

```{r}
# 整合两组数据
con_inc_data <- data.frame(idx = plot_data_con$idx, con = plot_data_con$mean_RT,
                           inc = plot_data_inc$mean_RT)
total_plot_data <- tidyr::pivot_longer(con_inc_data, cols = !idx, names_to = "Type", values_to = "RT")

ggplot(total_plot_data) + 
  geom_line(aes(x = idx, y = RT, color = Type)) + 
  theme_pubr()
```

## 5. 查看被试行为反应与模型估计参数的一致性

```{r}
# correlation
bl_list <- list()
rl_list <- list()
subject_list <- unique(raw_data$Subject_num)

count <- 1
for (single_sub in subject_list) {
    single_sub_data <- filter(raw_data, Subject_num == single_sub)
    bl_list[count] <- cor(single_sub_data$RT, single_sub_data$bl_sr_PE)
    rl_list[count] <- cor(single_sub_data$RT, single_sub_data$rl_sr_v_pe)

    count <- count + 1
}

bl_cor <- unlist(bl_list)
rl_cor <- unlist(rl_list)

tibble(BL = bl_cor, RL = rl_cor) %>%
    tidyr::pivot_longer(cols = c(BL, RL), names_to = "Type", values_to = "cor") %>%
    ggboxplot(x = "Type", y = "cor", fill = "Type", add = "jitter", ylab = "Pearson's r") -> corrplot
ggsave(here("data", "output", "plot", "corrplot.png"), corrplot, width = 4, height = 6)
```

```{r}
# linear regression
summary(lm(RT ~ bl_sr_PE + Response + congruency + run + block - 1, data = data_without_outlier))
summary(lm(RT ~ rl_sr_v_pe + Response + congruency + run + block - 1, data = data_without_outlier))

# linear regression for each sub
bl_result_list <- list()
rl_result_list <- list()
count_num <- 1

for (i in unique(data_without_outlier$Subject_num)) {
  single_sub_data <- filter(data_without_outlier, Subject_num == i)
  bl_result_list[[count_num]] <- 
    coef(lm(RT ~ bl_sr_PE + Response + congruency + run + block - 1, 
            data = single_sub_data))[[1]]
  rl_result_list[[count_num]] <- 
    coef(lm(RT ~ rl_sr_v_pe + Response + congruency + run + block - 1, 
            data = single_sub_data))[[1]]
  count_num <- count_num + 1
}
RA_
```

采用更为准确的方式查看被试行为反应与模型估计参数的一致性：

Model-based behavioral analysis 将不同的被试反应时分 bin，然后算出该 bin 内估计的 PE / P，绘制统计图表

```{r}
data_without_outlier %>% 
    select(Subject_num, RT, bl_sr_PE, rl_sr_v_pe) %>% 
    mutate(bin = cut(RT, breaks = seq(100,1600,200))) -> RA_sep_bin_analysis
```

```{r}
RA_sep_bin_analysis %>%
  group_by(bin) %>%
  summarise(mean_RT = mean(RT), 
            mean_BL_PE = mean(bl_sr_PE),
            mean_RL_PE = mean(rl_sr_v_pe)) %>%
  pivot_longer(cols = ends_with("_PE"), 
               names_to = "Model_Type", 
               values_to = "PE") %>%
  ggplot() +
  geom_point(aes(x = mean_RT, y = PE, shape = Model_Type), size = 2) +
  geom_smooth(aes(x = mean_RT, y = PE, color = Model_Type)) +
  facet_grid(Model_Type ~ .) + theme_pubr()
```
