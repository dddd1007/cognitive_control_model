---
title: "探索 CCC 对被试行为的影响"
output:
  html_document:
    df_print: paged
---

## 0. 导入数据与包
```{r}
library(tidyverse)
library(here)
raw_data <- read_csv(here(
    "data", "input",
    "subdata_with_alpha_decay.csv"
)) %>% 
  filter(Type == 1)
```
筛选超过3个标准差的 outlier:

```{r}
remove_outlier <- function(raw_table){
  removed_outlier_table <- raw_table[-which(raw_table$RT %in% boxplot(raw_table$RT, plot=FALSE)$out),]
  return(removed_outlier_table)
}

library(purrr)
raw_data %>% 
  split(.$Subject) %>% 
  map(remove_outlier) %>% 
  do.call(rbind, .) -> removed_outlier_data
```

## 1. 标记不同的 conflict 特征

因为 conflict 在小于 threshold 与否上存在质性的行为差异, 而小于 0 与否则反映了被试当前的行为是否与过去积累的行为模式价值 Q 矩阵的模式相反. 因此探讨被试对于如上三种不同条件进行区分分析就存在意义.

```{r}
conflict_type <- rep(0, nrow(removed_outlier_data))
for (i in seq_len(nrow(removed_outlier_data))) {
    if (removed_outlier_data[i, ]$if_below_CCC) {
        conflict_type[i] <- 2
    } else if (!removed_outlier_data[i, ]$if_below_CCC & removed_outlier_data[i, ]$conflict_value < 0) {
        conflict_type[i] <- 1
    } else if (!removed_outlier_data[i, ]$if_below_CCC & removed_outlier_data[i, ]$conflict_value >= 0) {
        conflict_type[i] <- 0
    }
}
head(conflict_type)
add_conflict_type_data <- cbind(removed_outlier_data, conflict_type)
```

将上述的type放于Excel并标记颜色, 发现1与2分布并不均匀, 于是考虑可能是在被试间有区别(如不同的被试可能threshold不同)或条件间存在差异, 抑或是先做和后做的run会有所不同. 因此对1和2的比例进行考量.
```{r}
add_conflict_type_data %>%
    filter(conflict_type == 2) %>%
    group_by(Subject, condition) %>%
    summarise(prop_type_2 = n())
add_conflict_type_data %>%
    filter(conflict_type == 1) %>%
    group_by(Subject, condition) %>%
    summarise(prop_type_1 = n())
add_conflict_type_data %>%
    filter(conflict_type == 2) %>%
    group_by(Subject) %>%
    summarise(prop_type_2 = n())
add_conflict_type_data %>%
    filter(conflict_type == 1) %>%
    group_by(Subject) %>%
    summarise(prop_type_1 = n())
```
随即, 我们按照比例区分 MI 和 MC 两种条件, 再查看每种条件下的比例
```{r}
add_conflict_type_data %>%
    filter(conflict_type == 2) %>%
    group_by(prop, congruency, condition) %>%
    summarise(prop_type_2 = n()) %>% 
    mutate(AVG = prop_type_2 / 36)
add_conflict_type_data %>%
    filter(conflict_type == 1) %>%
    group_by(prop, congruency, condition) %>%
    summarise(prop_type_1 = n()) %>% 
    mutate(AVG = prop_type_1 / 36)

add_conflict_type_data %>%
    group_by(prop, congruency, condition) %>%
    summarise(prop_type_1 = n()) %>% 
    mutate(AVG = prop_type_1 / 36)
```

由于在 MI 和 MC 下比例一致, 我们可以得到一个结论, 即 CCC 产生的效应是来源于局部, 而非受到全局的比例的调节.

添加 block 信息, 选择每次更改比例就相当于新block的定义
```{r}
change_block_index <- function(input_dataframe) {
    prop_value <- input_dataframe$prop
    block_value <- rep(0, length(prop_value))
    block_index <- 1
    last_prop <- prop_value[1]
    for (i in seq_len(length(prop_value))) {
        if (last_prop != prop_value[i]) {
            block_index <- block_index + 1
            last_prop <- prop_value[i]
        }
        block_value[i] <- block_index
    }
    input_dataframe$nblock <- block_value
    return(input_dataframe)
}

add_nblock_list <- list()
for (i in seq_len(18)) {
    foo <- filter(add_conflict_type_data, Subject_num == i)
    add_nblock_list[[i]] <- change_block_index(foo)
}

add_nblock_table <- do.call(rbind, add_nblock_list)
```

按照每个被试的 nblock 信息再看一下分布模式
```{r}
add_nblock_table %>%
    filter(conflict_type == 2) %>%
    group_by(Subject, nblock) %>%
    summarise(prop_type_2 = n()) %>%
    ggplot() +
    geom_line(aes(x = nblock, y = prop_type_2, colour = Subject))

add_nblock_table %>%
    filter(conflict_type == 1) %>%
    group_by(Subject, nblock) %>%
    summarise(prop_type_1 = n()) %>%
    ggplot() +
    geom_line(aes(x = nblock, y = prop_type_1, colour = Subject))
```

这个模式就比较有意思了. 之后再来探讨.

接下来比较反应时的差异.

## 2. 不同条件下 RT 模式

### 2.1 不同条件下的 RT 差异

我们比较上一个 conflict type 为 0, 1, 2 时, 随后的 trial 其反应时有什么特征.

本质上, 反应时的变化应该能够体现 Q-Matrix 的变化. 在前一个 trial 为 conflict < threshold 时, 应该出现应用极大的 alpha 值进行更新, 因此会导致在之后刺激相同的 trial 应当快于其他两种 conflict type 后的 trial, 而刺激不同的 trial 应当慢于其他两种 conflict type 后的 trial. 让我们先把这不同类型的 trial 挑出来.

```{r}
# 变量命名规则: 在 conflict type 为 x 之后且刺激空间位置相同, 刺激颜色相同/不同的trial => cx_sloc_s/dcolor
c2_sloc_scolor_index <- c()
c2_sloc_dcolor_index <- c()
c2_dloc_scolor_index <- c()
c2_dloc_dcolor_index <- c()

c1_sloc_scolor_index <- c()
c1_sloc_dcolor_index <- c()
c1_dloc_scolor_index <- c()
c1_dloc_dcolor_index <- c()

c0_sloc_scolor_index <- c()
c0_sloc_dcolor_index <- c()
c0_dloc_scolor_index <- c()
c0_dloc_dcolor_index <- c()

# 提取不同条件的index
for (idx in seq_len(nrow(add_nblock_table))) {
    if (idx == 1) {
        next
    }

    last_line <- add_nblock_table[idx - 1, ]
    current_line <- add_nblock_table[idx, ]

    if (last_line$conflict_type == 2) {
        if (last_line$stim_loc == current_line$stim_loc &
            last_line$stim_color == current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c2_sloc_scolor_index <- append(c2_sloc_scolor_index, idx)
        } else if (last_line$stim_loc == current_line$stim_loc &
            last_line$stim_color != current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c2_sloc_dcolor_index <- append(c2_sloc_dcolor_index, idx)
        } else if (last_line$stim_loc != current_line$stim_loc &
            last_line$stim_color == current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c2_dloc_scolor_index <- append(c2_dloc_scolor_index, idx)
        } else if (last_line$stim_loc != current_line$stim_loc &
            last_line$stim_color != current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c2_dloc_dcolor_index <- append(c2_dloc_dcolor_index, idx)
        }
    } else if (last_line$conflict_type == 1) {
        if (last_line$stim_loc == current_line$stim_loc &
            last_line$stim_color == current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c1_sloc_scolor_index <- append(c1_sloc_scolor_index, idx)
        } else if (last_line$stim_loc == current_line$stim_loc &
            last_line$stim_color != current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c1_sloc_dcolor_index <- append(c1_sloc_dcolor_index, idx)
        } else if (last_line$stim_loc != current_line$stim_loc &
            last_line$stim_color == current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c1_dloc_scolor_index <- append(c1_dloc_scolor_index, idx)
        } else if (last_line$stim_loc != current_line$stim_loc &
            last_line$stim_color != current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c1_dloc_dcolor_index <- append(c1_dloc_dcolor_index, idx)
        }
    } else if (last_line$conflict_type == 0) {
        if (last_line$stim_loc == current_line$stim_loc &
            last_line$stim_color == current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c0_sloc_scolor_index <- append(c0_sloc_scolor_index, idx)
        } else if (last_line$stim_loc == current_line$stim_loc &
            last_line$stim_color != current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c0_sloc_dcolor_index <- append(c0_sloc_dcolor_index, idx)
        } else if (last_line$stim_loc != current_line$stim_loc &
            last_line$stim_color == current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c0_dloc_scolor_index <- append(c0_dloc_scolor_index, idx)
        } else if (last_line$stim_loc != current_line$stim_loc &
            last_line$stim_color != current_line$stim_color &
            last_line$Subject == current_line$Subject &
            last_line$block == current_line$block) {
            c0_dloc_dcolor_index <- append(c0_dloc_dcolor_index, idx)
        }
    }
}
```

接下来开始验证不同类型的 trial 其反应时特征
```{r}
ttest_two_type_trials_RT <- function(input_dataframe, index1, index2) {
    x_name <- paste0("mean_", deparse(substitute(index1)))
    y_name <- paste0("mean_", deparse(substitute(index2)))

    vector_1 <- input_dataframe[index1, ]$RT
    vector_2 <- input_dataframe[index2, ]$RT

    p_value <- rep(0, 3)
    mean_x <- rep(0, 3)
    mean_y <- rep(0, 3)
    ttest_type <- c("two.sided", "less", "greater")

    result1 <- t.test(vector_1, vector_2, alternative = c("two.sided"))
    result2 <- t.test(vector_1, vector_2, alternative = c("less"))
    result3 <- t.test(vector_1, vector_2, alternative = c("greater"))

    p_value[1] <- result1$p.value
    p_value[2] <- result2$p.value
    p_value[3] <- result3$p.value

    mean_x[1] <- result1$estimate[1]
    mean_x[2] <- result2$estimate[1]
    mean_x[3] <- result3$estimate[1]

    mean_y[1] <- result1$estimate[2]
    mean_y[2] <- result2$estimate[2]
    mean_y[3] <- result3$estimate[2]

    total_result <- data.frame(p_value, mean_x, mean_y, ttest_type)

    colnames(total_result) <- c("p_value", x_name, y_name, "ttest_type")

    return(total_result)
}
```

#### 2.1.1 conflict 类型相同的 follow trial 的反应时差异
空间位置相同的前提下, 在小于 threshold 后的 trial 之后, 颜色相同的 trial 反应时应当远远小于颜色不同的 trial
```{r}
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_sloc_scolor_index, c2_sloc_dcolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c1_sloc_scolor_index, c1_sloc_dcolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c0_sloc_scolor_index, c0_sloc_dcolor_index
)
```
这个感觉好像没有什么意义?

#### 2.1.2 conflict 不同, 但前后刺激特征一致的 follow trial 的反应时差异
```{r}
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_sloc_scolor_index, c1_sloc_scolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_sloc_scolor_index, c0_sloc_scolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c1_sloc_scolor_index, c0_sloc_scolor_index
)
```

结果比较不算好, 我们用 APA 格式输出一下:
```{r}
library(report)
report(t.test(add_nblock_table$RT[c2_sloc_scolor_index], add_nblock_table$RT[c1_sloc_scolor_index]))
```

查看一下为什么结果变差了:

- RT的分布存在问题
- 样本量相差悬殊

```{r}
plot(density(add_nblock_table$RT[c2_sloc_scolor_index]))
plot(density(add_nblock_table$RT[c1_sloc_scolor_index]))

dgof::ks.test(add_nblock_table$RT[c2_sloc_scolor_index], "pnorm")
dgof::ks.test(add_nblock_table$RT[c1_sloc_scolor_index], "pnorm")
```

上述两组数据均呈现正偏态, 使用对数矫正:
```{r}
plot(density(log(add_nblock_table$RT[c2_sloc_scolor_index])))
plot(density(log(add_nblock_table$RT[c1_sloc_scolor_index])))
```

再次做 ttest
```{r}
t.test(log(add_nblock_table$RT[c2_sloc_scolor_index]), log(add_nblock_table$RT[c1_sloc_scolor_index]))
```

输出 APA 结果:
```{r}
report(t.test(log(add_nblock_table$RT[c2_sloc_scolor_index]), log(add_nblock_table$RT[c1_sloc_scolor_index])))
```
 


#### 2.1.3 conflict 不同, 前后刺激空间位置相同, 颜色不同的 trial 的反应时比较
```{r}
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_sloc_dcolor_index, c1_sloc_dcolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_sloc_dcolor_index, c0_sloc_dcolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c1_sloc_dcolor_index, c0_sloc_dcolor_index
)
```

#### 2.1.4 conflict 不同, 前后刺激空间位置不同, 颜色相同的 trial 反应时比较
```{r}
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_dloc_scolor_index, c1_dloc_scolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_dloc_scolor_index, c0_dloc_scolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c1_dloc_scolor_index, c0_dloc_scolor_index
)
```

### 2.1.5 dloc-dcolor
```{r}
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_dloc_dcolor_index, c1_dloc_dcolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c2_dloc_dcolor_index, c0_dloc_dcolor_index
)
ttest_two_type_trials_RT(
    add_nblock_table,
    c1_dloc_dcolor_index, c0_dloc_dcolor_index
)
```


从上述结果可以看出, 在 conflict 小于 threshold 和大于 threshold 之间, 被试表现出的行为特征是不同的:

- 前一个 trial 的 conflict 如小于 threshold, 则相比 conflict 为负但大于 threshold 的 trial, 其反应时明显更短.
- 前一个 trial 的 conflict 小于 0, 则后续的 trial 仍然存在冲突, 故反应时仍然大于跟随在无冲突的 trial 后的.

#### 2.2 不同条件下的 diff_RT 的差异
```{r}
ttest_two_type_trials_diffRT <- function(input_dataframe, index1, index2) {
    x_name <- paste0("mean_diff_", deparse(substitute(index1)))
    y_name <- paste0("mean_diff_", deparse(substitute(index2)))

    vector_1 <- input_dataframe[index1 - 1, ]$RT - input_dataframe[index1, ]$RT
    vector_2 <- input_dataframe[index2 - 1, ]$RT - input_dataframe[index2, ]$RT

    p_value <- rep(0, 3)
    mean_x <- rep(0, 3)
    mean_y <- rep(0, 3)
    ttest_type <- c("two.sided", "less", "greater")

    result1 <- t.test(vector_1, vector_2, alternative = c("two.sided"))
    result2 <- t.test(vector_1, vector_2, alternative = c("less"))
    result3 <- t.test(vector_1, vector_2, alternative = c("greater"))

    p_value[1] <- result1$p.value
    p_value[2] <- result2$p.value
    p_value[3] <- result3$p.value

    mean_x[1] <- result1$estimate[1]
    mean_x[2] <- result2$estimate[1]
    mean_x[3] <- result3$estimate[1]

    mean_y[1] <- result1$estimate[2]
    mean_y[2] <- result2$estimate[2]
    mean_y[3] <- result3$estimate[2]

    total_result <- data.frame(p_value, mean_x, mean_y, ttest_type)

    colnames(total_result) <- c("p_value", x_name, y_name, "ttest_type")

    return(total_result)
}
```

#### 2.2.1 相同刺激特征后的 diff_RT
```{r}
ttest_two_type_trials_diffRT(
    add_nblock_table,
    c2_sloc_scolor_index, c1_sloc_scolor_index
)
ttest_two_type_trials_diffRT(
    add_nblock_table,
    c2_sloc_scolor_index, c0_sloc_scolor_index
)
ttest_two_type_trials_diffRT(
    add_nblock_table,
    c1_sloc_scolor_index, c0_sloc_scolor_index
)
```

从上面的分析可以看出, 在 conflict < threshold 后的 trial, 其反应时陡然加快, 但加快的程度不存在显著差异.